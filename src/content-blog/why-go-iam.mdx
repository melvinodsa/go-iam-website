---
title: "Why Go IAM?"
date: "2025-09-24"
summary: "Explains the origins and motivations behind building Go IAM, focusing on real-world challenges in authentication and authorization."
navLabel: "why-go-iam"
navIcon: "book"
image: "/images/og/home.png"
---

![Why Go IAM](/images/og/home.png)

## The Origins âœ¨

Iâ€™ve been building authentication and authorization systems across almost every startup Iâ€™ve worked at since 2019. During my time at [Dezerv](https://www.dezerv.in), I faced one particularly interesting challenge.  

Internal employees needed access to certain dashboards, but the **same API** had to return **different results to different users** based on their access level. ğŸ”‘  

For example:  

- ğŸ‘¤ A **Relationship Manager (RM)** looking at onboarding applications should only see the leads they manageâ€”not the ones owned by other RMs.  
- ğŸ”„ The **`/v1/leads` API** should return filtered results tailored for each RM.  
- ğŸ‘¥ A **Team Manager** should see the *union* of applications from all their RMs, but with restricted visibilityâ€”some columns hidden, while RMs could still see them.  

Most developers solve this by writing custom RBAC logic directly into the application. But as soon as organizational hierarchies shift, that logic starts breaking and becomes painful to maintain. ğŸ¥´

---

### Early Go IAM Experiments âš™ï¸

The first versions of **Go IAM** (closed-source back then) were built around a simple principle:  

**Anything that needs access control is a resource.**  

- ğŸ“¦ Resources could be grouped into roles.  
- ğŸ”— Roles could be attached to users.  
- ğŸ—‚ï¸ Resources could have keysâ€”static or dynamic (e.g., `@data/application/71873`).  

This let applications offload access logic to the IAM layer instead of reinventing RBAC inside their codebase. However, one big learning emerged: applications still needed to **programmatically create resources and attach them to users**. This coupling exposed the limits of the early design, and paved the way for the open-source version of **Go IAM**. ğŸš€

---

### When IAM Saved the Day ğŸ›¡ï¸  

There was one incident where IAM quite literally saved us. While testing our **Systematic Investment Plan (SIP)** feature, a bug caused the application to start sending **infinite one-time passwords (OTPs)** via SMS. ğŸ“²ğŸ’¥  

With a quick action, we disabled the **SMS OTP permission** for the SIP service account directly through the IAM system. This immediately stopped the flood.  

That moment underscored an important lesson:  
ğŸ‘‰ You can never place blind trust in client applications not to make mistakes. IAM acts as a safety net when things go wrong.  

## The Present ğŸ”

At [Metadome](https://www.metadome.ai/), we implemented **Go IAM** once again. This time, one of the biggest pain points from earlier experiments was solved:  

âš¡ **No more manually attaching resources to roles and users.**  

Instead, **policies** automated the process:  

- ğŸ“ Any resource a user creates is automatically added to their access list.  
- ğŸ¯ Policies could also assign resources to specific users or roles.  
- ğŸ‘¨â€ğŸ’» This made it easy for testers to create application records even in production, while customers could simply be assigned a pre-created role.  

This shift from programmatic assignments to policy-driven automation drastically simplified the developer experience and reduced the chances of errors. ğŸš€

---

### IAM Meets AI ğŸ¤–

Another fascinating use case appeared when we opened up our infrastructure to AI.  

We were testing an **LLM-powered chatbot** and asked it to show cars of different colors. Harmless, right? But then, due to hallucination, the chatbot suddenly triggered a **service booking flow** through a tool call (via MCP). ğŸ˜…  

Luckily, nothing harmful happenedâ€”the user never went through with completing the booking. But the incident made us ask an important *what if*:  

ğŸ‘‰ What if the tool call had been something more sensitive, like **updating or deleting records in the database**?  

Thatâ€™s when the power of IAM became even more obvious. Imagine if IAM could **dynamically provision access** for both the user and the bot based on the conversation context. ğŸ›¡ï¸  

This idea hints at the next frontier: IAM systems that donâ€™t just enforce static policies but adapt in real-time to dynamic, AI-driven interactions.  

## The Future ğŸš€

As AI agents and LLMs continue to become integral to applications, security challenges grow in ways traditional RBAC and IAM were never designed to handle.  

An AI agent is not just *another user* â€” it can:  
- ğŸ”„ Call APIs on behalf of humans.  
- ğŸ§© Chain multiple tools together (MCP, plugins, services).  
- ğŸ“¦ Access sensitive data sources like PII, internal APIs, or even databases.  

This makes **access control the last line of defense** when things go wrong.  

---

### Controlling the MCP Layer âš™ï¸

The **Model Context Protocol (MCP)** allows LLMs to call tools and interact with external systems. But hereâ€™s the risk: hallucinations or prompt injection can push the agent to trigger actions that werenâ€™t intended.  

IAM can help by:  
- ğŸ” Restricting which tools an agent is allowed to call.  
- ğŸ›‘ Blocking unsafe actions (like database writes or deletes) unless explicitly provisioned.  
- â±ï¸ Dynamically granting short-lived permissions based on conversation context.  

This ensures the agent can only operate inside a *safe sandbox*, even when itâ€™s unpredictable.  

---

### Protecting the PII Layer ğŸ›¡ï¸

LLMs often need access to Personally Identifiable Information (PII) to be useful â€” but this data is highly sensitive.  

IAM can:  
- ğŸ¯ Enforce policies so agents see only the data they *absolutely need*.  
- ğŸ•µï¸ Redact or mask fields (e.g., hide phone numbers or partial email IDs) depending on the userâ€™s role.  
- ğŸ“Š Control column- or row-level access so no single query leaks more than intended.  

By layering IAM into the PII access pipeline, we create a **zero-trust boundary** between agents and sensitive data.  

---

### Securing Other AI Security Layers ğŸ§©

Beyond MCP and PII, IAM can extend into other layers of the AI stack:  

- ğŸ›‚ **Tool Access** â†’ Only authorized workflows should trigger certain high-risk tools (like payments, account updates, or deletion APIs).  
- ğŸ“¡ **External APIs** â†’ IAM can act as a gatekeeper, ensuring AI agents only call APIs theyâ€™re explicitly allowed to.  
- ğŸ”„ **Dynamic Access Provisioning** â†’ Just-in-time policies that grant access for the duration of a session or conversation, and then expire automatically.  

---

### The Next Step for Go IAM ğŸŒ

The future of **Go IAM** is about more than static RBAC. Itâ€™s about:  

- Context-aware, **real-time access control** for agents and LLMs.  
- A single IAM layer that spans **human users, bots, and AI systems**.  
- Security that is **adaptive, not hardcoded**.  

In a world where AI is becoming a first-class actor in our systems, IAM is the layer that ensures **safety, trust, and control**.  

